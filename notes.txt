TODO(cs): save smallest trace recorded so far. Not necessarily MCS!
TODO(cs): set up instrumentation: how long it took, how many executions, how
          many events replays, etc.
TODO(cs): probably need the equivalent of BeginWaitQuiescence for Continue
          events? And WaitTimer events?
TODO(cs): in GreedyED, if any repeating timer t went off k times in \tau^0, we should make sure it only goes
off k times in the executions we care about (i.e., we don't have to worry
about it going off infinitely, etc.)
TODO(cs): fix race condition in GreedyED
TODO(cs): edit-distance=0 evaluation (STSSched without Peek)
          Note: not strictly edit-distance=0, I think the EFF folks would say
          that if an expected event doesn't up, that's divergence, which is a
          stricter defn. of edit-distance=0.

---------------
TODO(cs): do we handle context.system.eventStream.publish properly? It's
          apparently only a local facility, not a cluster facility.
TODO(cs): raise exception if any of the other scheduler.schedule methods are
          called.
TODO(cs): should we be testing the cluster versions of the actors?
TODO(cs): double check: does akka-raft write anything to disk? Sort of seems
          like it doesn't support crash-recovery.. In fact, it doesn't make
          use of any of akka's persistence module...

----------- Random notes -----------

// Potentially useful:
http://stackoverflow.com/questions/17183308/scala-reflection-of-nested-list

// Andi's aspectj:
https://github.com/andiwundsam/floodlight-sync-proto/commit/d1e75dfb51b5d2d0847e5a4d2a3bc756df423bb0

// akka-raft Only uses:
import scala.concurrent.forkjoin.ThreadLocalRandom

----------- Timer notes ------------
Looks there are two uses of timers here:
  - cluster/ClusterRaftActor.scala uses schedule.scheduleOnce(), but I don't
    think it's actually crucial to the protocol. Looks like it's just used for
    cluster membership discovery.

    context.system.scheduler.scheduleOnce(identifyTimeout, self, onIdentityTimeout)

  - LoggingFSM.setTimer (part of the Akka) is used for heartbeats, etc.
    repeat is set to both true (for Leader) and false (for RaftActor)

  setTimer implementation:

  private[akka] case class Timer(name: String, msg: Any, repeat: Boolean, generation: Int)(context: ActorContext)
    extends NoSerializationVerificationNeeded {
    private var ref: Option[Cancellable] = _
    private val scheduler = context.system.scheduler
    private implicit val executionContext = context.dispatcher

    def schedule(actor: ActorRef, timeout: FiniteDuration): Unit =
      ref = Some(
        if (repeat) scheduler.schedule(timeout, timeout, actor, this)
        else scheduler.scheduleOnce(timeout, actor, this))


  So, the two scheduler interfaces used are:
    - scheduleOnce (delay: Duration, receiver: ActorRef, message: Any): Cancellable
    - schedule (initialDelay: Duration, frequency: Duration, receiver:ActorRef, message: Any): Cancellable
